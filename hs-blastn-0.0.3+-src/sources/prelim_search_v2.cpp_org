#include "search_worker.h"

#include <iostream>
using namespace std;
using namespace cy_utility;

/****************** Auxiliary datastructures and functions ***********************/

/* A subject will be split into several pieces in the preleminary stage if it is too long. */
/** Split subject sequences if longer than this */
static const Int4 MAX_DBSEQ_LEN = 5000000; 
/** By how much should the chunks of a subject sequence overlap if it is 
    too long and has to be split */
static const Int4 DBSEQ_CHUNK_OVERLAP = 100;

static inline Int8
GetSubjectBlock(Int8 offset)
{
	const Int8 r = (MAX_DBSEQ_LEN - DBSEQ_CHUNK_OVERLAP);
	Int8 block = offset / r;
	return block;
}
static inline Int8
GetSubjectBlockOffset(Int8 block)
{
	const Int8 r = (MAX_DBSEQ_LEN - DBSEQ_CHUNK_OVERLAP);
	Int8 offset = r * block;
	return offset;
}
static inline Int8
GetSubjectBlockEnd(Int8 block, Int8 subject_length)
{
	const Int8 r = (MAX_DBSEQ_LEN - DBSEQ_CHUNK_OVERLAP);
	Int8 start = GetSubjectBlockOffset(block);
	Int8 end = std::min(start + MAX_DBSEQ_LEN, subject_length);
	return end;
}

static inline int
CheckOverlapSeed(MEM* m, Int4 word_size)
{
	const Int8 r = (MAX_DBSEQ_LEN - DBSEQ_CHUNK_OVERLAP);
	Int4 b = m->soff / r;
	if (b == 0) return false;
	Int4 s = m->soff % r;
	if (s < DBSEQ_CHUNK_OVERLAP - word_size) return true;
	return false;
}

static void PrintMEM(MEM& m)
{
	printf("context = %d, sid = %ld, qoff = %d, soff = %ld, block_id = %d, block_offset = %d, diag = %d\n",
		   m.context, m.sid, m.qoff, m.soff, m.block_id, m.block_offset, m.diag);
}

struct MEMCmpSoff
{
	bool operator()(MEM* const m1, MEM* const m2)
	{
		if (m1->sid < m2->sid) return true;
		if (m1->sid > m2->sid) return false;
		if (m1->soff < m2->soff) return true;
		return false;
	}
};

struct MEMCmpContextSidBlockDiagQoff
{
	bool operator()(MEM* const m1, MEM* const m2)
	{
		if (m1->context < m2->context) return true;
		if (m1->context > m2->context) return false;
		if (m1->sid < m2->sid) return true;
		if (m1->sid > m2->sid) return false;
		if (m1->block_id < m2->block_id) return true;
		if (m1->block_id > m2->block_id) return false;
		if (m1->diag < m2->diag) return true;
		if (m1->diag > m2->diag) return false;
		if (m1->qoff < m2->qoff) return true;
		return false;
	}
};

void BuildBlockSeeds(SimpleArray<MEM*>& seeds,
					 Int4 word_size,
					 DbInfo* dbinfo,
					 SmallObjAllocator& soa)
{
	MEM** pseeds = (MEM**)seeds.get_data();
	Int4 num_seeds = seeds.size();
	Int4 i1 = 0, i2, i3, i4;
	MEM *m1, *m2, *m3;	
	
	for (i1 = 0; i1 < num_seeds; ++i1)
	{
		//PrintMEM(*pseeds[i1]);
	}
	
	cout << "before building ";
	cout << num_seeds << endl;
	std::sort(pseeds, pseeds + num_seeds, MEMCmpSoff());
	

	i1 = 0;
	while (i1 < num_seeds)
	{
		Int4 sid = seeds[i1]->sid;
		Int8 sl = dbinfo->GetSeqLength(sid);
		for (i2 = i1 + 1; i2 < num_seeds; ++i2)
		{
			if (seeds[i2]->sid != sid) break;
		}
		
		i3 = i1;
		while (i3 < i2)
		{
			m1 = seeds[i3];
			Int4 block = GetSubjectBlock(m1->soff);
			Int8 ss = GetSubjectBlockOffset(block);
			Int8 se = GetSubjectBlockEnd(block, sl) - DBSEQ_CHUNK_OVERLAP;
			
			for (i4 = i3; i4 < i2; ++i4)
			{
				m2 = seeds[i4];
				if (m2->soff == 64998749)
				{
					m2->block_offset = 1;
				}
				if (m2->soff >= se) break;
				if (m2->block_offset)
				{
					m3 = (MEM*)soa.Allocate(sizeof(MEM));
				}
				else
				{
					m3 = NULL;
				}
				
				m2->block_id = block;
				m2->block_offset = m2->soff - ss;
				m2->diag = m2->block_offset - m2->qoff;
				if (m2->block_offset > MAX_DBSEQ_LEN)
				{
					ASSERT(m2->block_offset < MAX_DBSEQ_LEN);
				}
				
				if (m3)
				{
					m3->context = m2->context;
					m3->sid = m2->sid;
					m3->block_id = block - 1;
					m3->qoff = m2->qoff;
					m3->block_offset = MAX_DBSEQ_LEN - DBSEQ_CHUNK_OVERLAP + m2->block_offset;
					m3->diag = m3->block_offset - m3->qoff;
					seeds.push_back(m3);
					
					if (m3->block_offset > MAX_DBSEQ_LEN)
					{
						ASSERT(m3->block_offset < MAX_DBSEQ_LEN);
					}
				}
			}
			i3 = i4;
		}
		i1 = i2;
	}
	
	pseeds = (MEM**)seeds.get_data();
	num_seeds = seeds.size();
	
	std::sort(pseeds, pseeds + num_seeds, MEMCmpContextSidBlockDiagQoff());
	
	cout << "after building" << num_seeds << endl << endl;
	for (i1 = 0; i1 < num_seeds; ++i1)
	{
		seeds[i1]->soff = 0;
		//PrintMEM(*seeds[i1]);
	}
	
	Int4 last_off = 0;
	Int4 sid;
	Int4 block;
	Int4 context;
	Int4 num_block_seeds;
	i1 = 0;
	while (i1 < num_seeds)
	{
		num_block_seeds = 1;
		m1 = pseeds[i1];
		sid = m1->sid;
		context = m1->context;
		block = m1->block_id;
		last_off = i1;
		for (i2 = i1 + 1; i2 < num_seeds; ++i2)
		{
			m2 = pseeds[i2];
			if (
				m2->context != context
				||
				m2->sid != sid
				||
				m2->block_id != block
				)
			{
				pseeds[last_off]->soff = num_block_seeds;
				break;
			}
			++num_block_seeds;
		}
		i1 = i2;
	}
	pseeds[last_off]->soff = num_block_seeds;
	
	cout << "after building" << num_seeds << endl << endl;
	for (i1 = 0; i1 < num_seeds; ++i1)
	{
		//if (seeds[i1]->soff >0)
		//	cout << "context seeds: " << seeds[i1]->soff << endl;
		//PrintMEM(*seeds[i1]);
	}
}

static inline
void ExtendLeft(const Uint1* q, Int4 qoff, const Uint1* s, Int4 soff, Int4 avail,
                Int4** matrix, Int4 X, Int4& ext, Int4& score)
{
    Int4 sum = 0;
    Int4 q_beg = qoff + 1;
    score = 0;
    ext = qoff;
    
    while (avail > 0)
    {
        Uint1 c = Blastna2Na2(s[soff]);
        sum += matrix[q[qoff]][c];
        if (sum > 0)
        {
            q_beg = qoff;
            score += sum;
            sum = 0;
        }
        else if (sum < X)
        {
            break;
        }
        --qoff;
        --soff;
        --avail;
    }
    ext = ext - q_beg + 1;
}

static inline
void ExtendRight(const Uint1* q, Int4 qoff, const Uint1* s, Int4 soff, Int4 avail,
				 Int4** matrix, Int4 X, Int4& ext, Int4& score)
{
    Int4 sum = 0;
    Int4 q_beg = qoff - 1;
    score = 0;
    ext = qoff;
    
    while (avail > 0)
    {
        Uint1 c = Blastna2Na2(s[soff]);
        sum += matrix[q[qoff]][c];
        if (sum > 0)
        {
            q_beg = qoff;
            score += sum;
            sum = 0;
        }
        else if (sum < X)
        {
            break;
        }
        ++qoff;
        ++soff;
        --avail;
    }
    ext = q_beg - ext + 1;
}

static inline void
s_SetHitValue(Hit& h, Int4 qoff, Int4 soff, Int4 ext_l,
              Int4 score_l, Int4 ext_r, Int4 score_r, Int4 context)
{
    h.qoff = qoff - ext_l;
    h.soff = soff - ext_l;
    h.score = score_l + score_r;
    h.len = ext_l + ext_r;
    h.context = context;
}

HSP* PrelimSearchStageOneSeed(MEM* m,
							  QueryInfo* query_info,
							  DbInfo* dbinfo,
							  BlastInitialWordParameters* word_params,
							  BlastScoreBlk* sbp,
							  BlastHitSavingParameters* hit_params,
							  GreedyAligner* gapped_aligner,
							  SmallObjAllocator& soa)
{
	Int4 context = m->context;
	const Uint1* query = query_info->GetSequence(context);
	Int4 query_length = query_info->GetSeqLength(context);
	
	const Uint1* subject = (const Uint1*)dbinfo->GetDb() + dbinfo->GetSeqOffset(m->sid);
	Int8 bs =  GetSubjectBlockOffset(m->block_id);
	Int8 be = GetSubjectBlockEnd(m->block_id, dbinfo->GetSeqLength(m->sid));
	subject = subject + bs;
	Int4 sl = be - bs;
	
	Int4 x_drop = -word_params->cutoffs[context].x_dropoff;
	Int4 ungapped_cutoff_score = word_params->cutoffs[context].cutoff_score;
	Int4 gapped_cutoff_score = hit_params->cutoffs[context].cutoff_score;
	Int4** matrix = sbp->matrix->data;
	
	Int4 ext_l, ext_r, score_l, score_r;
	
	Int4 avail = std::min(m->qoff, m->block_offset);
	ExtendLeft(query, m->qoff - 1, subject, m->block_offset - 1, avail, matrix, x_drop, ext_l, score_l);
	avail = std::min(query_length - m->qoff, sl - m->block_offset);
	ExtendRight(query, m->qoff, subject, m->block_offset, avail, matrix, x_drop, ext_r, score_r);
	
	Hit hit;
	s_SetHitValue(hit, m->qoff, m->block_offset, ext_l, score_l, ext_r, score_r, context);
	if (hit.score < ungapped_cutoff_score) return NULL;
	
	Int4 gapped_qstart_offset = hit.qoff + hit.len / 2;
	Int4 gapped_sstart_offset = hit.soff + hit.len / 2;
	
	gapped_aligner->GreedyGappedAlignment(query, 
										  subject, 
										  query_length, 
										  sl,
										  gapped_qstart_offset,
										  gapped_sstart_offset,
										  false, 
										  0);   
	
	if (gapped_aligner->gap_align.score < gapped_cutoff_score) return NULL;
	
	HSP* new_hsp = HSPNew(soa);
	gapped_aligner->PackHSP(*new_hsp, 0, bs);
	new_hsp->context = context;
	new_hsp->subject_id = m->sid;
	return new_hsp;
}

struct HitSortScore
{
	bool operator()(const Hit& pa, const Hit& pb)
	{
		if (pa.score > pb.score) return true;
		if (pa.score < pb.score) return false;
		if (pa.qoff < pb.qoff) return true;
		if (pa.qoff > pb.qoff) return false;
		return false;
	}
};

HSP* PrelimSearchStageMultipleSeeds(MEM** seeds,
									Int4 num_seeds,
							  QueryInfo* query_info,
							  DbInfo* dbinfo,
							  SimpleArray<Hit>& ungapped_alignments,
							  SimpleArray<HSP*>& gapped_alignments,
							  BlastInitialWordParameters* word_params,
							  BlastScoreBlk* sbp,
							  BlastHitSavingParameters* hit_params,
							  IntervalTree* itree,
							  Int4 min_diag_separation,
							  GreedyAligner* gapped_aligner,
							  SmallObjAllocator& soa)
{
	MEM* m = seeds[0];
	Int4 context = m->context;
	const Uint1* query = query_info->GetSequence(context);
	Int4 query_length = query_info->GetSeqLength(context);
	
	Int4 sid = m->sid;
	const Uint1* subject = (const Uint1*)dbinfo->GetDb() + dbinfo->GetSeqOffset(m->sid);
	Int8 bs =  GetSubjectBlockOffset(m->block_id);
	Int8 be = GetSubjectBlockEnd(m->block_id, dbinfo->GetSeqLength(m->sid));
	subject = subject + bs;
	Int4 sl = be - bs;
	
	Int4 x_drop = -word_params->cutoffs[context].x_dropoff;
	Int4 ungapped_cutoff_score = word_params->cutoffs[context].cutoff_score;
	Int4 gapped_cutoff_score = hit_params->cutoffs[context].cutoff_score;
	Int4** matrix = sbp->matrix->data;
	
	Int4 ext_l, ext_r, score_l, score_r, avail;
	Hit hit;
	HSP* new_hsp;
	ungapped_alignments.clear();
	
	Int4 i1 = 0, i2;
	Int4 q_ext_to = 0;
	Int4 diag;
	while (i1 < num_seeds)
	{
		q_ext_to = 0;
		diag = seeds[i1]->diag;
		for (i2 = i1; i2 < num_seeds; ++i2)
		{
			m = seeds[i2];
			if (m->diag != diag) break;
			if (m->qoff < q_ext_to) continue;
			ASSERT(m->block_offset < MAX_DBSEQ_LEN);
			avail = std::min(m->qoff, m->block_offset);
			ExtendLeft(query, m->qoff - 1, subject, m->block_offset - 1, avail, matrix, x_drop, ext_l, score_l);
			avail = std::min(query_length - m->qoff, sl - m->block_offset);
			ExtendRight(query, m->qoff, subject, m->block_offset, avail, matrix, x_drop, ext_r, score_r);
			
			s_SetHitValue(hit, m->qoff, m->block_offset, ext_l, score_l, ext_r, score_r, context);
			if (hit.score >= ungapped_cutoff_score)
			{
				ungapped_alignments.push_back(hit);
				ASSERT(hit.soff < MAX_DBSEQ_LEN);
			}
			q_ext_to = m->qoff + ext_r;
		}
		i1 = i2;
	}
	
	Int4 gapped_qstart;
	Int4 gapped_sstart;
	if (ungapped_alignments.size() == 1)
	{
		Hit& h = ungapped_alignments[0];
		gapped_qstart = h.qoff + h.len / 2;
		gapped_sstart = h.soff + h.len / 2;
		
		gapped_aligner->GreedyGappedAlignment(query, 
											  subject, 
											  query_length, 
											  sl,
											  gapped_qstart,
											  gapped_sstart,
											  false, 
											  0);   
		
		if (gapped_aligner->gap_align.score < gapped_cutoff_score) return NULL;
		
		new_hsp = HSPNew(soa);
		gapped_aligner->PackHSP(*new_hsp, 0, bs);
		new_hsp->context = context;
		new_hsp->subject_id = sid;
		gapped_alignments.push_back(new_hsp);
	}
	else
	{
		Hit* hits = (Hit*)ungapped_alignments.get_data();
		Int4 num_hits = ungapped_alignments.size();
		std::sort(hits, hits + num_hits, HitSortScore());
		itree->Reset(0, query_length + 1, 0, sl + 1);
		HSP hsp;
		Int4 last_num_gapped_alignments = gapped_alignments.size();
		for (i1 = 0; i1 < num_hits; ++i1)
		{
			hsp.q_off = hits[i1].qoff;
			hsp.q_end = hits[i1].qoff + hits[i1].len;
			hsp.s_off = hits[i1].soff;
			hsp.s_end = hits[i1].soff + hits[i1].len;
			hsp.score = hits[i1].score;
			
			if (itree->IntervalTreeContainsHSP(&hsp, min_diag_separation)) continue;
			
			gapped_qstart = hits[i1].qoff + hits[i1].len / 2;
			gapped_sstart = hits[i1].soff + hits[i1].len / 2;
			
			gapped_aligner->GreedyGappedAlignment(query, 
												  subject, 
												  query_length, 
												  sl,
												  gapped_qstart,
												  gapped_sstart,
												  false, 
												  0);   
			
			if (gapped_aligner->gap_align.score < gapped_cutoff_score) return NULL;
			
			new_hsp = HSPNew(soa);
			gapped_aligner->PackHSP(*new_hsp, 0, 0);
			new_hsp->context = context;
			new_hsp->subject_id = sid;
			gapped_alignments.push_back(new_hsp);
			itree->IntervalTreeAddHSP(new_hsp);
			new_hsp = NULL;
		}
		
		Int4 num_gapped_alignments = gapped_alignments.size() - last_num_gapped_alignments;
		Blast_HSPListPurgeHSPsWithCommonEndpoints(&gapped_alignments[last_num_gapped_alignments], num_gapped_alignments, TRUE, soa);
		gapped_alignments.set_array_size(last_num_gapped_alignments + num_gapped_alignments);

		for (int i = 0; i < num_gapped_alignments; ++i)
		{
			new_hsp = gapped_alignments[last_num_gapped_alignments + i];
			new_hsp->s_off += bs;
			new_hsp->s_end += bs;
			new_hsp->subject_gapped_start += bs;
		}
	}
}

void PrelimSearchStage(SimpleArray<MEM*>& seeds,
					   QueryInfo* query_info,
					   DbInfo* dbinfo,
					   Int4 seed_size,
					   SimpleArray<Hit>& ungapped_alignments,
					   SimpleArray<HSP*>& gapped_alignments,
					   BlastInitialWordParameters* word_params,
					   BlastScoreBlk* sbp,
					   BlastHitSavingParameters* hit_params,
					   IntervalTree* itree,
					   Int4 min_diag_separation,
					   GreedyAligner* gapped_aligner,
					   SmallObjAllocator& soa)
{
	Int4 i1, i2;
	Int4 num_seeds = seeds.size();
	MEM** pseeds = (MEM**)seeds.get_data();
	BuildBlockSeeds(seeds, seed_size, dbinfo, soa);
	
	gapped_alignments.clear();
	
	i1 = 0;
	Int4 last_context_alignments_offset = gapped_alignments.size();
	Int4 last_context = seeds[0]->context;
	Int4 num_context_gapped_alignments;
	num_seeds = seeds.size();
	while (i1 < num_seeds)
	{
		if (seeds[i1]->context != last_context)
		{
			num_context_gapped_alignments = gapped_alignments.size() - last_context_alignments_offset;
			gapped_alignments[last_context_alignments_offset]->num_ident = num_context_gapped_alignments;
			last_context_alignments_offset = gapped_alignments.size();
			last_context = seeds[i1]->context;
		}
		Int4 num_block_seeds = seeds[i1]->soff;
		
		if (num_block_seeds == 1)
		{
			HSP* new_hsp = PrelimSearchStageOneSeed(seeds[i1],
						   query_info,
						   dbinfo,
						   word_params,
						   sbp,
						   hit_params,
						   gapped_aligner,
						   soa);
			gapped_alignments.push_back(new_hsp);
		}
		else
		{
			PrelimSearchStageMultipleSeeds(pseeds + i1,
										   num_block_seeds,
										   query_info,
										   dbinfo,
										   ungapped_alignments,
										   gapped_alignments,
										   word_params,
										   sbp,
										   hit_params,
										   itree,
										   min_diag_separation,
										   gapped_aligner,
										   soa);
		}
		
		i1 += num_block_seeds;
	}
	
	num_context_gapped_alignments = gapped_alignments.size() - last_context_alignments_offset;
	if (num_context_gapped_alignments > 0)
	{
		gapped_alignments[last_context_alignments_offset]->num_ident = num_context_gapped_alignments;
	}
	
	printf("number of gapped alignments: %d\n", gapped_alignments.size());
	for (i1 = 0; i1 < gapped_alignments.size(); ++i1)
	{
		//HSPPrint(gapped_alignments[i1]);
	}
}
