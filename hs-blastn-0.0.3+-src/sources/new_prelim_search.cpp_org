
/*
 * file new_prelim_search.cpp
 * implement preliminary search stage of blastn
 */

#include "search_worker.h"
#include <iostream>
using namespace std;
using namespace cy_utility;

/****************** Auxiliary datastructures and functions ***********************/

/* A subject will be split into several pieces in the preleminary stage if it is too long. */
/** Split subject sequences if longer than this */
static const Int4 MAX_DBSEQ_LEN = 5000000; 
/** By how much should the chunks of a subject sequence overlap if it is 
    too long and has to be split */
static const Int4 DBSEQ_CHUNK_OVERLAP = 100;

static inline Int8
GetSubjectBlock(Int8 offset)
{
	const Int8 r = (MAX_DBSEQ_LEN - DBSEQ_CHUNK_OVERLAP);
	Int8 block = offset / r;
	return block;
}

static inline Int8
GetSubjectBlockOffset(Int8 block)
{
	const Int8 r = (MAX_DBSEQ_LEN - DBSEQ_CHUNK_OVERLAP);
	Int8 offset = r * block;
	return offset;
}
static inline Int8
GetSubjectBlockEnd(Int8 block, Int8 subject_length)
{
	const Int8 r = (MAX_DBSEQ_LEN - DBSEQ_CHUNK_OVERLAP);
	Int8 start = GetSubjectBlockOffset(block);
	Int8 end = std::min(start + MAX_DBSEQ_LEN, subject_length);
	return end;
}

static inline int
CheckOverlapChunk(Int4 block_offset, Int4 seed_size)
{
	if (block_offset < (DBSEQ_CHUNK_OVERLAP - seed_size)) return 1;
	return 0;
};

static inline int
CheckOverlapChunkNonBlockVersion(Int8 soff, Int4 seed_size)
{
	Int8 block = GetSubjectBlock(soff);
	if (block == 0) return 0;
	const Int8 r = (MAX_DBSEQ_LEN - DBSEQ_CHUNK_OVERLAP);
	Int8 block_offset = soff % r;
	if (block_offset < (DBSEQ_CHUNK_OVERLAP - seed_size)) return 1;
	return 0;
}

struct MEMCmpContextSidDiagQoff
{
	bool operator()(const MEM& m1, const MEM& m2)
	{
		if (m1.context < m2.context) return true;
		if (m1.context > m2.context) return false;
		if (m1.sid < m2.sid) return true;
		if (m1.sid > m2.sid) return false;
		if (m1.diag < m2.diag) return true;
		if (m1.diag > m2.diag) return false;
		if (m1.qoff < m2.qoff) return true;
		if (m1.qoff > m2.qoff) return false;
		return false;
	}
};	

void PrintMEM(MEM& m)
{
	cout << "context = " << m.context << ", diag = " << m.diag << ", qoff = " << m.qoff << ", soff = " << m.soff << endl;
}

void PrintMEMList(SimpleArray<MEM>& seeds)
{
	Int4 num_seeds = seeds.size(), i;
	for (i = 0; i < num_seeds; ++i)
	{
		cout << i << "\t";
		PrintMEM(seeds[i]);
	}
}

void PrintMEMList(MEM* seeds, Int4 num_seeds)
{
	Int4 i;
	for (i = 0; i < num_seeds; ++i)
	{
		cout << i << "\t";
		PrintMEM(seeds[i]);
	}
}

static inline void
s_SetHitValue(Hit& h, Int4 qoff, Int4 soff, Int4 ext_l,
              Int4 score_l, Int4 ext_r, Int4 score_r, Int4 context)
{
    h.qoff = qoff - ext_l;
    h.soff = soff - ext_l;
    h.score = score_l + score_r;
    h.len = ext_l + ext_r;
    h.context = context;
}

void PrintHit(Hit& m)
{
	cout << "context = " << m.context << ", len = " << m.len << ", qoff = " << m.qoff << ", soff = " << m.soff << endl;
}

void ExtendLeft(const Uint1* q, Int4 qoff, const Uint1* s, Int4 soff, Int4 avail,
                Int4** matrix, Int4 X, Int4& ext, Int4& score)
{
    Int4 sum = 0;
    Int4 q_beg = qoff + 1;
    score = 0;
    ext = qoff;
    
    while (avail > 0)
    {
        Uint1 c = Blastna2Na2(s[soff]);
        sum += matrix[q[qoff]][c];
        if (sum > 0)
        {
            q_beg = qoff;
            score += sum;
            sum = 0;
        }
        else if (sum < X)
        {
            break;
        }
        --qoff;
        --soff;
        --avail;
    }
    ext = ext - q_beg + 1;
}

void ExtendRight(const Uint1* q, Int4 qoff, const Uint1* s, Int4 soff, Int4 avail,
				 Int4** matrix, Int4 X, Int4& ext, Int4& score)
{
    Int4 sum = 0;
    Int4 q_beg = qoff - 1;
    score = 0;
    ext = qoff;
    
    while (avail > 0)
    {
        Uint1 c = Blastna2Na2(s[soff]);
        sum += matrix[q[qoff]][c];
        if (sum > 0)
        {
            q_beg = qoff;
            score += sum;
            sum = 0;
        }
        else if (sum < X)
        {
            break;
        }
        ++qoff;
        ++soff;
        --avail;
    }
    ext = q_beg - ext + 1;
}


void PrelimSearchStageOneContextOneDiagOneSubjectWithoutOverlapSeeds(MEM* seeds, 
		Int4 num_seeds,
		Int4 seed_size,
		QueryInfo* query_info,
		Int8 sid,
		Int8 sl,
		DbInfo* dbinfo,
		SimpleArray<Hit>& ungapped_alignments,
		SimpleArray<HSP*>& gapped_alignments,
		BlastScoreBlk* sbp,
		BlastInitialWordParameters* word_params,
		BlastHitSavingParameters* hit_params,
		IntervalTree* itree,
		Int4 min_diag_separation,
		GreedyAligner* gapped_aligner,
		SmallObjAllocator& soa)
{
	cout << __func__ << endl;
	Int4 index;
	Int4 context = seeds[0].context;
	const Uint1* query = query_info->GetSequence(context);
	Int4 query_length = query_info->GetSeqLength(context);
	Int4 query_start = query_info->GetContextOffset(context);
	const Uint1* subject = (const Uint1*)dbinfo->GetDb() + dbinfo->GetSeqOffset(sid);
	
	HSP hsp; hsp.subject_id = sid;
	Hit hit;
	HSP* new_hsp;
	
	Int4 score_l, score_r, ext_l, ext_r;
	Int4 x_drop = -word_params->cutoffs[context].x_dropoff;
	Int4 ungapped_cutoff_score = word_params->cutoffs[context].cutoff_score;
	Int4 gapped_cutoff_score = hit_params->cutoffs[context].cutoff_score;
	Int4** matrix = sbp->matrix->data;
	Int8 extend_to = -1;
	
	ungapped_alignments.clear();
	for (index = 0; index < num_seeds; ++index)
	{
		if (seeds[index].soff < extend_to) continue;
		if (seeds[index].soff + seed_size > sl) break;
		
		Int4 qoff = seeds[index].qoff - query_start;
		Int4 avail = qoff;
		if (avail > seeds[index].soff) avail = seeds[index].soff;
		ExtendLeft(query, qoff - 1, subject, seeds[index].soff - 1, avail, matrix, x_drop, ext_l, score_l);
		
		avail = query_length - qoff;
		if (avail > (sl - seeds[index].soff)) avail = sl - seeds[index].soff;
		ExtendRight(query, qoff, subject, seeds[index].soff, avail, matrix, x_drop, ext_r, score_r);
		
		if (score_l + score_r >= ungapped_cutoff_score)
		{
			s_SetHitValue(hit, qoff, seeds[index].soff, ext_l, score_l, ext_r, score_r, context);
			ungapped_alignments.push_back(hit);
			extend_to = seeds[index].soff + ext_r;
		}
		PrintHit(hit);
		ungapped_alignments.push_back(hit);
	}
	
	Int4 last_gapped_offset = gapped_alignments.size();
	Int4 num_ungapped_alignments = ungapped_alignments.size();
	itree->Reset(0, query_length + 1, 0, sl + 1);
	for (index = 0; index < num_ungapped_alignments; ++index)
	{
		hsp.q_off = ungapped_alignments[index].qoff;
		hsp.q_end = hsp.q_off + ungapped_alignments[index].len;
		hsp.s_off = ungapped_alignments[index].soff;
		hsp.s_end = hsp.s_off + ungapped_alignments[index].len;
		hsp.score = ungapped_alignments[index].score;
		
		if (itree->IntervalTreeContainsHSP(&hsp, min_diag_separation)) continue;
		
		Int4 qoff = hsp.q_off + ungapped_alignments[index].len / 2;
		Int8 soff = hsp.s_off + ungapped_alignments[index].len / 2;
		Int8 adjust_shift, adjust_subject_length = sl, adjust_subject_offset = soff;
		
		AdjustSubjectRange(&adjust_subject_offset,
						   &adjust_subject_length,
						   qoff,
						   query_length,
						   &adjust_shift);
		
		const Uint1* adjust_subject = subject + adjust_shift;
		
		gapped_aligner->GreedyGappedAlignment(query, 
											  adjust_subject, 
											  query_length, 
											  adjust_subject_length,
											  qoff,
											  adjust_subject_offset, 
											  false, 
											  0);   
		
		cout << context << "\t";
		cout << gapped_aligner->gap_align.score << endl;
		if (gapped_aligner->gap_align.score < gapped_cutoff_score) continue;
		
		new_hsp = HSPNew(soa);
		gapped_aligner->PackHSP(*new_hsp, 0, adjust_shift);
		new_hsp->context = context;
		new_hsp->subject_id = sid;
		gapped_alignments.push_back(new_hsp);
		itree->IntervalTreeAddHSP(new_hsp);  
		HSPPrint(new_hsp);
		new_hsp = NULL;
	}
	
	Int4 num_gapped_alignments = gapped_alignments.size() - last_gapped_offset;
	Blast_HSPListPurgeHSPsWithCommonEndpoints(&gapped_alignments[last_gapped_offset], num_gapped_alignments, TRUE, soa);
	gapped_alignments.set_array_size(last_gapped_offset + num_gapped_alignments);
}

void PrelimSearchStageOneContextOneDiagOneSubjectWithOverlapSeeds(MEM* seeds, 
										Int4 num_seeds,
										Int4 seed_size,
										QueryInfo* query_info,
										Int8 sid,
										Int8 sl,
										DbInfo* dbinfo,
										SimpleArray<Hit>& ungapped_alignments,
										SimpleArray<HSP*>& gapped_alignments,
										BlastScoreBlk* sbp,
										BlastInitialWordParameters* word_params,
										BlastHitSavingParameters* hit_params,
										IntervalTree* itree,
										Int4 min_diag_separation,
										GreedyAligner* gapped_aligner,
										SmallObjAllocator& soa)
{
	cout << __func__ << endl;
	//PrintMEMList(seeds, num_seeds);
	int index, index1, index2;
	Int4 block, next_block = 0;
	Int4 block_offset, block_length;
	Int8 block_start, block_end;
	Int4 next_block_seed_index;
	bool next_block_seed_detected;
	Int4 extend_to;
	Int4 context = seeds[0].context;
	const Uint1* query = query_info->GetSequence(context);
	Int4 query_length = query_info->GetSeqLength(context);
	Int4 query_start = query_info->GetContextOffset(context);
	const Uint1* subject = (const Uint1*)dbinfo->GetDb() + dbinfo->GetSeqOffset(sid);
	HSP hsp; hsp.subject_id = sid;
	Hit hit;
	HSP* new_hsp;
	
	Int4 score_l, score_r, ext_l, ext_r;
	Int4 x_drop = -word_params->cutoffs[context].x_dropoff;
	Int4 ungapped_cutoff_score = word_params->cutoffs[context].cutoff_score;
	Int4 gapped_cutoff_score = hit_params->cutoffs[context].cutoff_score;
	Int4** matrix = sbp->matrix->data;
	
	for (index = 0; index < num_seeds; ++index)
	{
		if (next_block)
		{
			block = next_block;
		}
		else
		{
			block = GetSubjectBlock(seeds[index].soff);
			block_start = GetSubjectBlockOffset(block);
			block_offset = seeds[index].soff - block_start;
			if ((block > 0) && CheckOverlapChunk(block_offset, seed_size))
				--block;
		}

		block_start = GetSubjectBlockOffset(block);
		block_end = GetSubjectBlockEnd(block, sl);
		block_length = block_end - block_start;
		extend_to = -1;
		ungapped_alignments.clear();
		next_block_seed_index = -1;
		const Uint1* block_subject = subject + block_start;
		for (index1 = index; index1 < num_seeds; ++index1)
		{
			if (seeds[index1].soff >= block_end) break;
			block_offset = seeds[index1].soff - block_start;
			Int4 diff = block_end - seeds[index1].soff;
			if (diff < seed_size) break;
			if ((!next_block_seed_detected) && (diff <= DBSEQ_CHUNK_OVERLAP) && (diff >= seed_size))
			{
				next_block_seed_detected = true;
				next_block_seed_index = index1;
			}
			
			if (block_offset < extend_to) continue;
			
			cout << "ungapped alignments" << endl;
			
			Int4 qoff = seeds[index1].qoff - query_start;
			Int4 soff = block_offset;
			Int4 avail = std::min(qoff, soff);
			ExtendLeft(query, qoff - 1, block_subject, soff - 1, avail, matrix, x_drop, ext_l, score_l);
			
			avail = std::min(query_length - qoff, block_length - soff);
			ExtendRight(query, qoff, block_subject, soff, avail, matrix, x_drop, ext_r, score_r);
			
			if (score_l + score_r >= ungapped_cutoff_score)
			{
				s_SetHitValue(hit, qoff, soff, ext_l, score_l, ext_r, score_r, context);
				ungapped_alignments.push_back(hit);
				extend_to = soff + ext_r;
			}
			ungapped_alignments.push_back(hit);
		}
		
		itree->Reset(0, query_length + 1, 0, block_length + 1);
		Int4 last_gapped_offset = gapped_alignments.size();
		for (index2 = 0; index2 < ungapped_alignments.size(); ++index2)
		{
			hsp.q_off = ungapped_alignments[index2].qoff;
			hsp.q_end = hsp.q_off + ungapped_alignments[index2].len;
			hsp.s_off = ungapped_alignments[index2].soff;
			hsp.s_end = hsp.s_off + ungapped_alignments[index2].len;
			hsp.score = ungapped_alignments[index2].score;
			
			if (itree->IntervalTreeContainsHSP(&hsp, min_diag_separation)) continue;
			
			Int4 qoff = hsp.q_off + ungapped_alignments[index2].len / 2;
			Int4 soff = hsp.s_off + ungapped_alignments[index2].len / 2;
			
			cout << "gapped alignments" << endl;
			gapped_aligner->GreedyGappedAlignment(query, 
												  block_subject, 
												  query_length, 
												  block_length,
												  qoff ,
												  soff, 
												  false, 
												  0);   
			
			cout << context << "\t";
			cout << gapped_aligner->gap_align.score << endl;
			if (gapped_aligner->gap_align.score < gapped_cutoff_score) continue;
			
			new_hsp = HSPNew(soa);
			gapped_aligner->PackHSP(*new_hsp, 0, 0);
			new_hsp->context = context;
			new_hsp->subject_id = sid;
			gapped_alignments.push_back(new_hsp);
			itree->IntervalTreeAddHSP(new_hsp);   
			new_hsp = NULL;
		}
		
		Int4 num_gapped_alignments = gapped_alignments.size() - last_gapped_offset;
		Blast_HSPListPurgeHSPsWithCommonEndpoints(&gapped_alignments[last_gapped_offset], num_gapped_alignments, TRUE, soa);
		gapped_alignments.set_array_size(last_gapped_offset + num_gapped_alignments);
		
		for (index2 = last_gapped_offset; index2 < gapped_alignments.size(); ++index2)
		{
			new_hsp = gapped_alignments[index2];
			new_hsp->s_off += block_start;
			new_hsp->s_end += block_start;
			new_hsp->subject_gapped_start += block_start;
			HSPPrint(new_hsp);
		}
		
		if (next_block_seed_detected)
		{
			next_block = block + 1;
			index = next_block_seed_index;
		}
		else
		{
			index = index1;
			next_block = 0;
		}
	}
}

void PrelimSearchStageOneContextOneDiag(MEM* seeds, 
										Int4 num_seeds,
										Int4 seed_size,
										QueryInfo* query_info,
										DbInfo* dbinfo,
										SimpleArray<Hit>& ungapped_alignments,
										SimpleArray<HSP*>& gapped_alignments,
										BlastScoreBlk* sbp,
										BlastInitialWordParameters* word_params,
										BlastHitSavingParameters* hit_params,
										IntervalTree* itree,
										Int4 min_diag_separation,
										GreedyAligner* gapped_aligner,
										SmallObjAllocator& soa)
{
	cout << __func__ << endl;
	//PrintMEMList(seeds, num_seeds);
	Int4 index = 0, index1;
	Int8 sid, sl;
	Int8 s_start, s_end;
	bool has_overlap_seeds;
	while (index < num_seeds)
	{
		sid = dbinfo->GetSeqId(seeds[0].soff);
		s_start = dbinfo->GetSeqOffset(sid);
		sl = dbinfo->GetSeqLength(sid);
		s_end = s_start + sl - seed_size + 1;
		has_overlap_seeds = false;
		for (index1 = index; index1 < num_seeds; ++index1)
		{
			if (seeds[index1].soff > s_end) break;
			seeds[index1].soff -= s_start;
			if ((!has_overlap_seeds) && CheckOverlapChunkNonBlockVersion(seeds[index1].soff, seed_size)) has_overlap_seeds = true;
		}
		
		if (has_overlap_seeds)
		PrelimSearchStageOneContextOneDiagOneSubjectWithOverlapSeeds(seeds + index,
				index1 - index,
				seed_size,
				query_info,
				sid,
				sl,
				dbinfo,
				ungapped_alignments,
				gapped_alignments,
				sbp,
				word_params,
				hit_params,
				itree,
				min_diag_separation,
				gapped_aligner,
				soa);
		else
			PrelimSearchStageOneContextOneDiagOneSubjectWithoutOverlapSeeds(seeds + index,
					index1 - index,
					seed_size,
					query_info,
					sid,
					sl,
					dbinfo,
					ungapped_alignments,
					gapped_alignments,
					sbp,
					word_params,
					hit_params,
					itree,
					min_diag_separation,
					gapped_aligner,
					soa);
			
		
		index = index1;
	}
}

void PrelimSearchStageOneContext(MEM* seeds, 
								 Int4 num_seeds,
								 Int4 seed_size,
								 QueryInfo* query_info,
								 DbInfo* dbinfo,
								 SimpleArray<Hit>& ungapped_alignments,
								 SimpleArray<HSP*>& gapped_alignments,
								 BlastScoreBlk* sbp,
								 BlastInitialWordParameters* word_params,
								 BlastHitSavingParameters* hit_params,
								 IntervalTree* itree,
								 Int4 min_diag_separation,
								 GreedyAligner* gapped_aligner,
								 SmallObjAllocator& soa)
{
	cout << __func__ << endl;
	//PrintMEMList(seeds, num_seeds);
	Int4 index = 0, index1;
	while (index < num_seeds)
	{
		Int8 diag = seeds[index].diag;
		for (index1 = index + 1; index1 < num_seeds; ++index1)
		{
			if (seeds[index1].diag != diag) break;
		}
		Int4 num_diag_seeds = index1 - index;
		PrelimSearchStageOneContextOneDiag(seeds + index,
										   num_diag_seeds,
										   seed_size,
										   query_info,
										   dbinfo,
										   ungapped_alignments,
										   gapped_alignments,
										   sbp,
										   word_params,
										   hit_params,
										   itree,
										   min_diag_separation,
										   gapped_aligner,
										   soa);
		index = index1;
	}
}
								 

void PrelimSearchStage(SimpleArray<MEM>& seeds,
					   QueryInfo* query_info,
					   DbInfo* dbinfo,
					   Int4 seed_size,
					   SimpleArray<HSP*>& gapped_alignments,
					   BlastInitialWordParameters* word_params,
					   BlastScoreBlk* sbp,
					   BlastHitSavingParameters* hit_params,
					   IntervalTree* itree,
					   Int4 min_diag_separation,
					   GreedyAligner* gapped_aligner,
					   SmallObjAllocator& soa)
{
	PrintMEMList(seeds);
	cout << "number of seeds " << seeds.size() << endl;
	MEM* pseeds = (MEM*)seeds.get_data();
	Int4 num_seeds = seeds.size();
	std::sort(pseeds, pseeds + num_seeds, MEMCmpContextSidDiagQoff());
	PrintMEMList(pseeds, num_seeds);
	SimpleArray<Hit> ungapped_alignments;
	gapped_alignments.clear();
	Int4 index = 0, index1, index2;
	while (index < num_seeds)
	{
		Int4 context = seeds[index].context;
		for (index1 = index + 1; index1 < num_seeds; ++index1)
		{
			if (seeds[index1].context != context) break;
		}
		Int4 num_context_seeds = index1 - index;
		index2 = gapped_alignments.size();
		PrelimSearchStageOneContext(pseeds + index,
										   num_context_seeds,
										   seed_size,
										   query_info,
										   dbinfo,
										   ungapped_alignments,
										   gapped_alignments,
										   sbp,
										   word_params,
										   hit_params,
										   itree,
										   min_diag_separation,
										   gapped_aligner,
										   soa);
		index = index1;
		Int4 num_context_alignments = gapped_alignments.size() - index2;
		cout << "number of context gapped alignments: " << num_context_alignments << endl;
		if (num_context_alignments > 0)
		{
			gapped_alignments[index2]->num_ident = num_context_alignments;
		}
	}
}
